# Terrain Generator

A terrain generation and visualization module extracted from Shuaijun Liu's UAV simulation project. Uses Python to generate terrain data and visualizes it in the browser using Three.js.

![Terrain Visualization](screen.png)

## Quick Start

### 1. Install Dependencies

```bash
cd terrain_generator
pip install -r requirements.txt
```

### 2. Generate Terrain Data

```bash
python3 generate_terrain.py
```

This will generate `data/terrain_data.json` with terrain, buildings, trees, and user positions.

### 3. Start Visualization Server

**Method 1: Use Start Script (Recommended)**

```bash
./start_server.sh
```

**Method 2: Manual Start**

```bash
python3 -m http.server 8000
```

### 4. View Visualization

Open in your browser:

```
http://localhost:8000/visualize.html
```

**Controls**:
- **Left mouse drag**: Rotate view
- **Right mouse drag**: Pan view
- **Mouse wheel**: Zoom

---

## Features

- **Python Data Generation**: Generate terrain, buildings, trees, user positions, and other data using Python, saved as JSON
- **Web Visualization**: Real-time 3D terrain rendering in the browser using Three.js
- **Complete Terrain System**: Includes city buildings, mountain buildings, trees, lakes, user positions, and other elements
- **Trajectory Path Display**: Display trajectory paths on the terrain (hidden by default, callable when needed). See [PATH_USAGE.md](PATH_USAGE.md) for details.

## Project Structure

```
terrain_generator/
├── README.md                  # This file
├── requirements.txt           # Python dependencies
├── generate_terrain.py       # Python main script: generates terrain data
├── terrain_utils.py          # Python utility functions: terrain calculation, building generation, etc.
├── config.py                 # Configuration file: constant definitions
├── start_server.sh           # Quick start script
├── visualize.html            # Visualization page
├── screen.png                # Screenshot of the visualization
├── js/                       # JavaScript modules
│   ├── OrbitControls.js      # Three.js camera controls
│   ├── terrain_loader.js     # Data loading logic
│   ├── terrain_utils.js      # JS utility functions (terrain height calculation, etc.)
│   └── terrain_renderer.js   # Three.js rendering logic
└── data/                     # Data directory
    └── terrain_data.json     # Generated terrain data (generated by Python)
```

## Installation

### Install Python Dependencies

```bash
cd terrain_generator
pip install -r requirements.txt
```

**Dependencies**:
- `opensimplex` - Simplex noise generation (for terrain generation)

## Usage

### Step 1: Generate Terrain Data

Run the Python script to generate terrain data:

```bash
python3 generate_terrain.py [seed]
```

**Parameters**:
- `seed` (optional): Random number seed. If not provided, current timestamp will be used as seed
- Same seed will generate the same terrain data

**Examples**:
```bash
# Use specified seed
python3 generate_terrain.py 12345

# Use random seed (current time)
python3 generate_terrain.py
```

**Generated Data**:
- File location: `data/terrain_data.json`
- Contains:
  - City buildings: 1,300
  - Mountain buildings: 200
  - Trees: 4,000
  - User positions: 6
  - Lakes: 3
  - Terrain sample points: ~4,770
  - Mountain regions: ~5-10 (pre-analyzed mountain areas with height and position information)

### Step 2: Start Visualization Server

Due to browser CORS security restrictions, you cannot directly open the HTML file by double-clicking. You must use a web server.

**Method 1: Use Start Script (Recommended)**

```bash
./start_server.sh
```

**Method 2: Manual Start**

```bash
python3 -m http.server 8000
```

The server will start at `http://localhost:8000`.

### Step 3: View Visualization

Open in your browser:

```
http://localhost:8000/visualize.html
```

The page will automatically load `data/terrain_data.json` and render the 3D terrain.

## Controls

In the visualization page:

- **Left mouse drag**: Rotate view
- **Right mouse drag**: Pan view
- **Mouse wheel**: Zoom

## Terrain Data Specification

### Map Dimensions and Precision

- **Map Size**: 1000 × 1000 meters (square)
- **Coordinate System**: 
  - Origin (0, 0) at map center
  - X-axis: -500 to +500 meters (East-West)
  - Z-axis: -500 to +500 meters (North-South)
  - Y-axis: Height above sea level
- **Maximum Altitude**: 150.0 meters
- **Terrain Height Precision**: 
  - Continuous calculation: Float precision (high precision)
  - Sampled terrain map: 0.1 meter precision (1 decimal place)
  - Sampling interval: 10 meters (TERRAIN_SAMPLE_STEP)
- **Building Position Precision**: Float precision (typically 6-8 decimal places)
- **Coordinate Units**: All values in meters

### Terrain Generation Algorithm

The terrain height is calculated using **multi-octave SimplexNoise**:

1. **City Boundary**: Variable radius (140 ± 60 meters) based on angular noise
2. **Mountain Height**: Three-layer noise combination:
   - Large scale: `noise(x*0.005, z*0.005) * 120` meters
   - Medium scale: `noise(x*0.015, z*0.015) * 45` meters
   - Small scale: `noise(x*0.05, z*0.05) * 10` meters
3. **Transition Zone**: 40 meters smooth transition from city to mountains
4. **Lake Blending**: Smoothstep interpolation for lake banks (0.4 meter bank width)

**Important**: The terrain height function is **deterministic** - same seed produces identical terrain. Use the provided `TerrainUtils` class (JavaScript) or `TerrainGenerator` class (Python) to calculate terrain height at any point.

### Data Structure

The generated terrain data (`terrain_data.json`) contains the following fields:

```json
{
  "seed": 12345.0,              // Random number seed (float)
  "mapSize": 1000,              // Map size in meters (integer)
  "maxAltitude": 150.0,         // Maximum altitude in meters (float)
  
  "lakes": [                    // Lake definitions (array)
    {
      "x": 10,                  // Center X coordinate (meters)
      "z": 5,                   // Center Z coordinate (meters)
      "rx": 20,                 // Radius in X direction (meters)
      "rz": 18,                 // Radius in Z direction (meters)
      "rot": 0                  // Rotation angle in radians
    }
  ],
  
  "cityBuildings": [            // City buildings (array, ~1,300 items)
    {
      "x": 104.56,              // Center X coordinate (meters, float)
      "z": -61.94,              // Center Z coordinate (meters, float)
      "halfWidth": 2.94,        // Half width in X direction (meters, float)
      "halfDepth": 2.54,        // Half depth in Z direction (meters, float)
      "height": 30.49           // Total height from ground (meters, float)
    }
  ],
  
  "mountainBuildings": [         // Mountain buildings (array, ~200 items)
    {
      "x": 392.01,              // Center X coordinate (meters, float)
      "z": 259.52,              // Center Z coordinate (meters, float)
      "halfWidth": 2.37,        // Half width (square building, meters, float)
      "halfDepth": 2.37,        // Half depth (square building, meters, float)
      "height": 37.24,          // Total height from baseHeight (meters, float)
      "baseHeight": 23.74        // Base height on terrain (meters, float)
    }
  ],
  
  "buildingColliders": [...],   // Combined collision data (city + mountain buildings)
  
  "cabinPositions": [           // Cabin positions for tree generation exclusion
    {
      "x": 392.01,              // Center X coordinate (meters, float)
      "z": 259.52,              // Center Z coordinate (meters, float)
      "r": 5.0                  // Exclusion radius (meters, float)
    }
  ],
  
  "trees": [                    // Tree positions (array, ~4,000 items)
    {
      "x": 16.75,               // X coordinate (meters, float)
      "y": 26.57,               // Y coordinate (height, meters, float)
      "z": -408.60,             // Z coordinate (meters, float)
      "scale": 1.43,            // Scale factor (float)
      "rotation": 0.05          // Rotation angle in radians (float)
    }
  ],
  
  "finalUsers": [               // User positions (array, 6 items)
    {
      "x": 26.14,               // X coordinate (meters, float)
      "y": 8.70,                // Y coordinate (height, meters, float)
      "z": 50.16                // Z coordinate (meters, float)
    }
  ],
  
  "terrainMap": [               // Sampled terrain height points (legacy format, array, ~6,000 items)
    {
      "x": -500,                // X coordinate (meters, integer, 10m intervals)
      "z": -500,                // Z coordinate (meters, integer, 10m intervals)
      "y": 23.8                 // Terrain height (meters, float, 0.1m precision)
    }
  ],
  
  "heightMap": {                // Complete terrain height map (NEW, recommended for trajectory planning)
    "heightMap": [               // 2D array of heights, row-major: heightMap[z_index][x_index]
      [113.44, 111.76, ...],    // First row (Z = -500m)
      [112.30, 110.52, ...],    // Second row (Z = -498m)
      ...                        // 501 rows total
    ],
    "origin": [-500, -500],     // Origin coordinates [x_min, z_min] (meters)
    "step": 2.0,                // Resolution in meters (float)
    "size": [501, 501],         // Grid size [width, depth] in cells (integers)
    "xCoords": [-500, -498, ...], // X coordinates for each column (optional, for fast lookup)
    "zCoords": [-500, -498, ...]  // Z coordinates for each row (optional, for fast lookup)
  },
  
  "mountainRegions": [          // Mountain region definitions (array, ~5-10 regions)
    {
      "minX": -500,             // Minimum X boundary (meters, integer)
      "maxX": -300,             // Maximum X boundary (meters, integer)
      "minZ": 400,              // Minimum Z boundary (meters, integer)
      "maxZ": 500,              // Maximum Z boundary (meters, integer)
      "minHeight": 32.0,        // Minimum height in region (meters, float)
      "maxHeight": 118.6,       // Maximum height in region (meters, float)
      "avgHeight": 79.2,        // Average height in region (meters, float)
      "pointCount": 8,          // Number of sample points in region (integer)
      "centerX": -388,          // Center X coordinate (meters, integer)
      "centerZ": 475,           // Center Z coordinate (meters, integer)
      "centerHeight": 79.2      // Height at center point (meters, float)
    }
  ]
}
```

### Height Map (Complete Terrain Data)

The `heightMap` field contains **complete terrain data** for trajectory planning:

- **Format**: 2D array, row-major order: `heightMap[z_index][x_index]`
- **Resolution**: 2 meters (configurable)
- **Coverage**: Complete 1000m × 1000m map (-500 to +500 meters)
- **Total Points**: 251,001 points (501 × 501 grid)
- **Precision**: 2 decimal places (0.01m)
- **File Size**: ~2 MB (additional to other data)

**Usage**:
```python
from terrain_generator.height_map_utils import HeightMap
import json

# Load and use height map
with open('data/terrain_data.json') as f:
    data = json.load(f)

height_map = HeightMap(data['heightMap'])
height = height_map.get_height(x, z)  # Fast O(1) lookup
```

**Advantages over terrainMap**:
- Complete coverage (all points have height values)
- Higher precision (2m vs 10m resolution)
- Faster lookup (O(1) direct indexing vs O(n) nearest neighbor)
- No interpolation needed
- Perfect for trajectory planning to avoid terrain collisions

**Why heightMap is 2D (not 3D)**:
- Terrain height is a function of horizontal position: `y = f(x, z)`
- For any given (x, z) coordinate, there is exactly one terrain height value
- The height map stores: `heightMap[z_index][x_index] = y_value`
- This is 2D because we only need to index by x and z to get the height y

**How to use 2D heightMap for 3D trajectory planning**:
- Trajectory points are 3D: `(x, y, z)` where:
  - `x, z`: Horizontal position (from trajectory planning algorithm)
  - `y`: Vertical position (altitude)
- For each trajectory point `(x, y, z)`:
  1. Query terrain height: `terrain_height = heightMap.get_height(x, z)`
  2. Check collision: `if y < terrain_height + safety_margin: collision = True`
  3. Adjust trajectory: `y = max(y, terrain_height + safety_margin)`
- The trajectory is 3D, but terrain is represented as 2D height field (height as function of x, z)

See [TERRAIN_STORAGE.md](TERRAIN_STORAGE.md) for detailed documentation.

### Mountain Region Information

The `mountainRegions` array provides pre-analyzed mountain area information for trajectory planning:

- **Identification Criteria**: 
  - Minimum height: 30 meters
  - Must be outside city boundary (20m buffer beyond city limit)
  - Minimum area: 4 connected sample points (200m² minimum)
- **Analysis Resolution**: 50-meter grid (5× sampling step for efficiency)
- **Data Provided for Each Region**:
  - **Bounding Box**: `minX`, `maxX`, `minZ`, `maxZ` - Defines the rectangular area
  - **Height Range**: `minHeight`, `maxHeight`, `avgHeight` - Height statistics
  - **Center Point**: `centerX`, `centerZ`, `centerHeight` - Geographic center and elevation
  - **Size**: `pointCount` - Number of sample points (indicates region size)

**Usage for Trajectory Planning**:
- Quickly identify high-altitude areas without checking every terrain point
- Check if trajectory waypoints intersect mountain regions using bounding boxes
- Use `avgHeight` or `centerHeight` for approximate elevation when planning
- Consider higher altitude requirements (safety margin) when passing through mountains
- Typical mountain regions: 5-10 regions per map, covering outer areas

**Example Usage**:
```python
# Check if a point is in a mountain region
def is_in_mountain_region(x, z, mountain_regions):
    for region in mountain_regions:
        if (region['minX'] <= x <= region['maxX'] and 
            region['minZ'] <= z <= region['maxZ']):
            return region
    return None

# Get approximate height for a mountain region
region = is_in_mountain_region(waypoint_x, waypoint_z, data['mountainRegions'])
if region:
    recommended_altitude = region['avgHeight'] + 10  # 10m safety margin
```

### Building Collision Detection

For trajectory planning, use `buildingColliders` which contains all buildings with collision information:

- **City Buildings**: 
  - Collision box: `[x - halfWidth - buffer, x + halfWidth + buffer]` × `[z - halfDepth - buffer, z + halfDepth + buffer]` × `[0, height + buffer]`
  - Recommended buffer: 10 meters for safety margin
- **Mountain Buildings**:
  - Collision box: `[x - halfWidth - buffer, x + halfWidth + buffer]` × `[z - halfDepth - buffer, z + halfDepth + buffer]` × `[baseHeight, height + buffer]`
  - Note: `baseHeight` may be negative (extended below terrain for visual stability)

### Reconstructing Complete Terrain Map from Data

**Yes, the JSON file now contains complete terrain data including mountain structures!**

The JSON file contains:
1. **Complete height map**: `heightMap` (2m resolution, 251,001 points) - **NEW, Recommended**
2. **Deterministic seed**: Allows exact terrain regeneration
3. **Terrain generation parameters**: Lakes, city boundaries, etc.
4. **Sampled terrain points**: `terrainMap` (10m intervals, ~6,000 points, legacy format)
5. **Mountain region summaries**: `mountainRegions` (pre-analyzed areas)

**Important**: The JSON file now stores **complete terrain data** in the `heightMap` field:
- **2-meter resolution** height map covering the entire 1000m × 1000m map
- **251,001 precise height points** (501 × 501 grid)
- **Fast O(1) lookup** using direct indexing
- **Complete coverage** - every point in the map has a height value

For trajectory planning, you can now directly use the `heightMap` data without needing to regenerate terrain from the seed.

#### Method 1: Use Height Map (Recommended - Fast and Complete)

**Python** (Recommended for trajectory planning):
```python
from terrain_generator.height_map_utils import HeightMap
import json

# Load terrain data
with open('data/terrain_data.json') as f:
    world_state = json.load(f)

# Initialize height map
height_map = HeightMap(world_state['heightMap'])

# Get terrain height at any point (fast O(1) lookup)
height = height_map.get_height(x, z)

# Or use bilinear interpolation for smoother results
height = height_map.get_height_interpolated(x, z)

# Check if point is in bounds
if height_map.is_in_bounds(x, z):
    height = height_map.get_height(x, z)
```

**Advantages**:
- Complete terrain coverage (all points have height values)
- Fast lookup (O(1) with direct indexing)
- High precision (2m resolution)
- No need to regenerate terrain from seed
- Compact storage (2D array format)

#### Method 2: Use Terrain Generation Function (Alternative - On-demand Calculation)

If you prefer to calculate terrain height on-demand using the generation algorithm:

**Python**:
```python
from terrain_utils import TerrainGenerator, Mulberry32Random
from opensimplex import OpenSimplex
import json

# Load terrain data
with open('data/terrain_data.json') as f:
    world_state = json.load(f)

# Initialize terrain generator
rng = Mulberry32Random(int(world_state['seed']))
simplex = OpenSimplex(int(world_state['seed']))
terrain_gen = TerrainGenerator(simplex, world_state['lakes'], rng)

# Get terrain height at any point
height = terrain_gen.get_terrain_height(x, z)
```

**JavaScript**:
```javascript
// Load terrain data
const worldState = await fetch('data/terrain_data.json').then(r => r.json());

// Initialize terrain utilities
const simplex = new SimplexNoise(/* seed-based random function */);
const terrainUtils = new TerrainUtils(worldState, simplex);

// Get terrain height at any point
const height = terrainUtils.getTerrainHeight(x, z);
```

**Use this method when**:
- You need exact algorithm-based height (not pre-sampled)
- You want to calculate heights outside the map bounds
- You prefer on-demand calculation over pre-stored data

#### Method 3: Interpolate from Sampled Terrain Map (Legacy)

If you prefer to use the pre-sampled `terrainMap`:

```python
import numpy as np
from scipy.interpolate import griddata

# Load terrain data
terrain_data = json.load(open('data/terrain_data.json'))
terrain_map = terrain_data['terrainMap']

# Extract coordinates and heights
points = np.array([[p['x'], p['z']] for p in terrain_map])
heights = np.array([p['y'] for p in terrain_map])

# Interpolate height at query point (x, z)
height = griddata(points, heights, (x, z), method='cubic')
```

**Note**: Method 3 (interpolation) has limited precision due to 10-meter sampling interval and may miss details. **Use Method 1 (heightMap) for trajectory planning** - it provides complete terrain with 2m resolution and fast lookup.

If you need a complete terrain height map for trajectory planning:

**Python**:
```python
from terrain_utils import TerrainGenerator, Mulberry32Random
from opensimplex import OpenSimplex
import json
import numpy as np

# Load terrain data
with open('data/terrain_data.json') as f:
    world_state = json.load(f)

# Initialize terrain generator
rng = Mulberry32Random(int(world_state['seed']))
simplex = OpenSimplex(int(world_state['seed']))
terrain_gen = TerrainGenerator(simplex, world_state['lakes'], rng)

# Generate full terrain grid (1m resolution example)
resolution = 1.0  # meters
half = int(world_state['mapSize'] / 2)
terrain_grid = {}

for x in range(-half, half + 1, int(resolution)):
    for z in range(-half, half + 1, int(resolution)):
        height = terrain_gen.get_terrain_height(x, z)
        terrain_grid[(x, z)] = height

# Or use numpy array for faster access
xs = np.arange(-half, half + 1, resolution)
zs = np.arange(-half, half + 1, resolution)
terrain_array = np.zeros((len(xs), len(zs)))

for i, x in enumerate(xs):
    for j, z in enumerate(zs):
        terrain_array[i, j] = terrain_gen.get_terrain_height(x, z)
```

**Mountain Structure**: Mountain structures are represented by terrain height. Areas with height > 30m and outside city boundaries are considered mountains. Use `mountainRegions` for quick identification, or calculate height at any point to determine if it's mountainous.

### Terrain Height Calculation Details

The terrain height function `getTerrainHeight(x, z)` works as follows:

1. Calculate distance from origin: `dist = sqrt(x² + z²)`
2. Calculate angle: `angle = atan2(z, x)`
3. Get city boundary at angle: `cityLimit = 140 + noise(cos(angle), sin(angle)) * 60`
4. If `dist > cityLimit`:
   - Calculate mountain height using multi-octave noise
   - Apply smoothstep transition (40m transition zone)
5. Check lake boundaries:
   - If inside lake: return water level (-2m)
   - If near lake bank: blend with smoothstep (0.4m bank width)
6. Return final height: `mountainHeight * lakeBlend`

**Precision**: The function provides continuous height values (float precision) for any (x, z) coordinate within the map bounds.

### For Trajectory Planning

When planning trajectories using this terrain data:

1. **Complete Terrain Access**:
   - **Yes, the JSON file contains complete terrain data**: Use `heightMap` field (2m resolution, 251,001 points)
   - **Fast lookup**: Use `HeightMap.get_height(x, z)` for O(1) height queries
   - **Complete coverage**: Every point in the 1000m × 1000m map has a height value
   - **Mountain structures** are represented by terrain height values in the height map
   - **Alternative**: You can also use `getTerrainHeight(x, z)` with the seed to calculate on-demand

2. **Collision Avoidance**:
   - Check all points in `buildingColliders` with 10m buffer
   - Use `getTerrainHeight(x, z)` to ensure altitude > terrain + safety margin
   - Consider tree positions if needed (trees are ~6m tall, typically at terrain height)
   - Use `mountainRegions` to quickly identify high-altitude areas

3. **Height Constraints**:
   - Minimum altitude: `max(terrainHeight, buildingHeight + buffer) + safetyMargin`
   - Maximum altitude: 150.0 meters (MAX_ALT)
   - Recommended safety margin: 5-10 meters
   - For mountain regions: Use `region['avgHeight'] + safetyMargin` as minimum

4. **Coordinate System**:
   - All coordinates in meters
   - Origin (0, 0, 0) at map center
   - Y-axis is height (upward positive)
   - Map bounds: X, Z from -500 to +500 meters

5. **Deterministic Behavior**:
   - Same seed produces identical terrain
   - Use the same seed and terrain generation code for consistency
   - Terrain height is deterministic for any (x, z) coordinate
   - **Complete terrain can be reconstructed** from JSON data using the seed

6. **Mountain Structure Access**:
   - **Method 1**: Use `mountainRegions` for quick region identification
   - **Method 2**: Calculate `getTerrainHeight(x, z)` at any point - if height > 30m and outside city, it's mountainous
   - **Method 3**: Pre-generate terrain grid at desired resolution (see Method 3 above)

## FAQ

### Q: Why can't I open the HTML file directly by double-clicking?

A: Browser CORS security policies do not allow `file://` protocol to access local files. You must use a web server.

### Q: Getting "Load failed" or "CORS error"?

A: Make sure:
1. You have run `python3 generate_terrain.py` to generate the data file
2. You are accessing via web server (not opening the file directly)
3. The data file exists at `data/terrain_data.json`

### Q: How to stop the server?

A: Press `Ctrl+C` in the terminal running the server

### Q: How to generate new terrain?

A: Running `python3 generate_terrain.py` will overwrite the existing `data/terrain_data.json` file. Using different seeds will generate different terrain.

### Q: Browser console shows error messages?

A: If you see `Immersive Translate ERROR` or similar errors, these are from browser extensions (like translation plugins) and do not affect the terrain visualization functionality. They can be safely ignored.

## Technical Details

### Random Number Compatibility

- Python and JavaScript use the same Mulberry32 random number algorithm
- Same seed produces the same results in both environments

### SimplexNoise Compatibility

- Python uses `opensimplex` library
- JavaScript uses `simplex-noise` library
- Both produce compatible noise values

### Performance Optimization

- Uses `InstancedMesh` to render large numbers of buildings and trees
- Terrain height calculated in real-time (for collision detection, etc.)
- User markers use Sprite rendering, always visible

## Development Notes

### Modifying Configuration

Edit `config.py` to modify:
- Map size and height limits
- Building counts
- Tree counts
- Lake definitions
- Other generation parameters

### Customizing Visualization

Edit `js/terrain_renderer.js` to modify:
- Rendering styles
- Marker appearance
- Camera settings
- Lighting configuration

## Author

Created by **Shuaijun Liu**

This project is extracted from the UAV simulation project and retains the original project's license.

## License

This project is extracted from the UAV simulation project and retains the original project's license.
